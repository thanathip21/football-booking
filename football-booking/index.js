// const express = require("express");
// const cors = require("cors");
// const bcrypt = require("bcrypt");
// const jwt = require("jsonwebtoken");
// const pool = require("./db");

// const app = express();
// app.use(cors());
// app.use(express.json());

// // ====================================
// // üîê AUTHENTICATION APIs
// // ====================================

// // POST /register - ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å
// app.post("/register", async (req, res) => {
//   const { username, password, email, full_name, phone } = req.body;

//   if (!username || !password || !email) {
//     return res.status(400).json({ 
//       message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å username, password ‡πÅ‡∏•‡∏∞ email" 
//     });
//   }

//   try {
//     // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ username ‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
//     const checkUser = await pool.query(
//       "SELECT * FROM users WHERE username = $1",
//       [username]
//     );

//     if (checkUser.rows.length > 0) {
//       return res.status(400).json({ 
//         message: "Username ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß" 
//       });
//     }

//     // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™ password ‡∏î‡πâ‡∏ß‡∏¢ bcrypt
//     const saltRounds = 10;
//     const hashedPassword = await bcrypt.hash(password, saltRounds);

//     // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á database
//     const result = await pool.query(
//       `INSERT INTO users (username, password_hash, email, full_name, phone, role) 
//        VALUES ($1, $2, $3, $4, $5, 'customer') 
//        RETURNING user_id, username, email, full_name, role, created_at`,
//       [username, hashedPassword, email, full_name || null, phone || null]
//     );

//     res.status(201).json({
//       message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
//       user: result.rows[0]
//     });

//   } catch (err) {
//     console.error(err);
//     res.status(500).json({ message: "Server error" });
//   }
// });

// // POST /login - ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö
// app.post("/login", async (req, res) => {
//   const { username, password } = req.body;

//   if (!username || !password) {
//     return res.status(400).json({ 
//       message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å username ‡πÅ‡∏•‡∏∞ password" 
//     });
//   }

//   try {
//     // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ user
//     const result = await pool.query(
//       "SELECT * FROM users WHERE username = $1",
//       [username]
//     );

//     if (result.rows.length === 0) {
//       return res.status(401).json({ 
//         message: "Username ‡∏´‡∏£‡∏∑‡∏≠ Password ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" 
//       });
//     }

//     const user = result.rows[0];

//     // ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö password
//     const isMatch = await bcrypt.compare(password, user.password_hash);

//     if (!isMatch) {
//       return res.status(401).json({ 
//         message: "Username ‡∏´‡∏£‡∏∑‡∏≠ Password ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" 
//       });
//     }

//     // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token
//     const token = jwt.sign(
//       { 
//         user_id: user.user_id, 
//         username: user.username,
//         role: user.role 
//       },
//       process.env.JWT_SECRET,
//       { expiresIn: "24h" }
//     );

//     res.json({
//       message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
//       token: token,
//       user: {
//         user_id: user.user_id,
//         username: user.username,
//         email: user.email,
//         full_name: user.full_name,
//         role: user.role
//       }
//     });

//   } catch (err) {
//     console.error(err);
//     res.status(500).json({ message: "Server error" });
//   }
// });

// // ====================================
// // üîí Middleware ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Token
// // ====================================
// function authenticateToken(req, res, next) {
//   const authHeader = req.headers["authorization"];
//   const token = authHeader && authHeader.split(" ")[1];

//   if (!token) {
//     return res.status(401).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö Token ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ Login" });
//   }

//   jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
//     if (err) {
//       return res.status(403).json({ message: "Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
//     }
//     req.user = user;
//     next();
//   });
// }

// // GET /profile - ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡∏ï‡πâ‡∏≠‡∏á Login)
// app.get("/profile", authenticateToken, async (req, res) => {
//   try {
//     const result = await pool.query(
//       `SELECT user_id, username, email, full_name, phone, role, created_at 
//        FROM users WHERE user_id = $1`,
//       [req.user.user_id]
//     );

//     if (result.rows.length === 0) {
//       return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ" });
//     }

//     res.json(result.rows[0]);
//   } catch (err) {
//     console.error(err);
//     res.status(500).json({ message: "Server error" });
//   }
// });

// // ====================================
// // ‚öΩ APIs ‡∏™‡∏ô‡∏≤‡∏°‡∏ü‡∏∏‡∏ï‡∏ö‡∏≠‡∏•
// // ====================================

// // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á slots ‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô 12:00-00:00
// function generateTimeSlots(start = "12:00", end = "00:00", slotMinutes = 60) {
//   const slots = [];
//   let [h, m] = start.split(":").map(Number);
//   let [endH, endM] = end === "00:00" ? [24, 0] : end.split(":").map(Number);

//   while (h < endH || (h === endH && m < endM)) {
//     const startTime = `${h.toString().padStart(2, "0")}:${m
//       .toString()
//       .padStart(2, "0")}`;
//     let nextH = h + Math.floor((m + slotMinutes) / 60);
//     let nextM = (m + slotMinutes) % 60;
//     const endTimeSlot =
//       nextH === 24
//         ? "00:00"
//         : `${nextH.toString().padStart(2, "0")}:${nextM
//             .toString()
//             .padStart(2, "0")}`;
//     slots.push({ start_time: startTime, end_time: endTimeSlot });
//     h = nextH;
//     m = nextM;
//   }

//   return slots;
// }

// // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤ HH:MM ‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏≤‡∏ó‡∏µ
// function timeToMinutes(t) {
//   const [h, m] = t.split(":").map(Number);
//   return h * 60 + m;
// }

// // GET /pitches - ‡∏î‡∏π‡∏™‡∏ô‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
// app.get("/pitches", async (req, res) => {
//   try {
//     const result = await pool.query("SELECT * FROM pitches ORDER BY pitch_id");
//     res.json(result.rows);
//   } catch (err) {
//     console.error(err);
//     res.status(500).send("Server error");
//   }
// });

// // GET /pitches/available-slots?date=YYYY-MM-DD
// app.get("/pitches/available-slots", async (req, res) => {
//   const { date } = req.query;
//   if (!date)
//     return res
//       .status(400)
//       .json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á date ‡πÄ‡∏õ‡πá‡∏ô query param ‡πÄ‡∏ä‡πà‡∏ô 2025-10-23" });

//   const slots = generateTimeSlots();

//   try {
//     const bookings = await pool.query(
//       `SELECT pitch_id, start_time, end_time FROM bookings WHERE booking_date = $1`,
//       [date]
//     );

//     const pitches = await pool.query(`SELECT * FROM pitches ORDER BY pitch_id`);
//     const result = [];

//     pitches.rows.forEach((pitch) => {
//       const availableSlots = slots.filter((slot) => {
//         return !bookings.rows.some(
//           (b) =>
//             b.pitch_id === pitch.pitch_id &&
//             timeToMinutes(slot.start_time) < timeToMinutes(b.end_time) &&
//             timeToMinutes(slot.end_time) > timeToMinutes(b.start_time)
//         );
//       });
//       result.push({
//         pitch_id: pitch.pitch_id,
//         name: pitch.name,
//         slots: availableSlots,
//       });
//     });

//     res.json(result);
//   } catch (err) {
//     console.error(err);
//     res.status(500).send("Server error");
//   }
// });

// // POST /bookings - ‡∏à‡∏≠‡∏á‡∏™‡∏ô‡∏≤‡∏° (‡∏ï‡πâ‡∏≠‡∏á Login)
// app.post("/bookings", authenticateToken, async (req, res) => {
//   const { pitch_id, booking_date, start_time, duration_hours } = req.body;
//   const user_id = req.user.user_id; // ‡∏î‡∏∂‡∏á user_id ‡∏à‡∏≤‡∏Å Token

//   if (!pitch_id || !booking_date || !start_time || !duration_hours) {
//     return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å field" });
//   }

//   // ‡πÅ‡∏õ‡∏•‡∏á duration ‡πÄ‡∏õ‡πá‡∏ô end_time
//   let [h, m] = start_time.split(":").map(Number);
//   let endH = h + Number(duration_hours);
//   let end_time = `${(endH % 24).toString().padStart(2, "0")}:${m
//     .toString()
//     .padStart(2, "0")}`;

//   try {
//     // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
//     const check = await pool.query(
//       `SELECT * FROM bookings 
//        WHERE pitch_id=$1 AND booking_date=$2
//          AND start_time < $3 AND end_time > $4`,
//       [pitch_id, booking_date, end_time, start_time]
//     );

//     if (check.rows.length > 0) {
//       return res
//         .status(400)
//         .json({ message: "‡∏™‡∏ô‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ" });
//     }

//     // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å booking
//     const result = await pool.query(
//       `INSERT INTO bookings (user_id, pitch_id, booking_date, start_time, end_time, status)
//        VALUES ($1,$2,$3,$4,$5,'confirmed') RETURNING *`,
//       [user_id, pitch_id, booking_date, start_time, end_time]
//     );

//     res.json(result.rows[0]);
//   } catch (err) {
//     console.error(err);
//     res.status(500).send("Server error");
//   }
// });

// // -----------------------------
// // Start server
// // -----------------------------
// const PORT = 3000;
// app.listen(PORT, () => console.log(`Server running on port ${PORT}`));


const express = require("express");
const cors = require("cors");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const pool = require("./db"); // ‡∏î‡∏∂‡∏á Connection Pool ‡∏à‡∏≤‡∏Å db.js
require('dotenv').config(); // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏•‡∏î JWT_SECRET ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏≠‡∏∑‡πà‡∏ô ‡πÜ

const app = express();
app.use(cors());
// Middleware ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ Express ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô JSON Body ‡πÑ‡∏î‡πâ
app.use(express.json());

// ====================================
// üíö HEALTH CHECK API (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ DB)
// ====================================

// GET /health - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
app.get("/health", async (req, res) => {
    try {
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Query ‡∏á‡πà‡∏≤‡∏¢ ‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡πá‡∏Ñ Pool Connection
        await pool.query("SELECT 1+1 AS result"); 
        res.json({ 
            status: "OK", 
            message: "API Server is running and DB connection is good!" 
        });
    } catch (err) {
        console.error("DB Connection Error:", err.message);
        // ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏ß‡∏¢ HTTP 503 (Service Unavailable) ‡∏´‡∏≤‡∏Å‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
        res.status(503).json({ 
            status: "Error", 
            message: "Database connection failed. Check your .env config and Docker container status." 
        });
    }
});

// ====================================
// üîê AUTHENTICATION APIs
// ====================================

// POST /register - ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å
app.post("/register", async (req, res) => {
¬† const { username, password, email, full_name, phone } = req.body;

¬† if (!username || !password || !email) {
¬† ¬† return res.status(400).json({ 
¬† ¬† ¬† message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å username, password ‡πÅ‡∏•‡∏∞ email" 
¬† ¬† });
¬† }

¬† try {
¬† ¬† // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ username ‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
¬† ¬† const checkUser = await pool.query(
¬† ¬† ¬† "SELECT * FROM users WHERE username = $1",
¬† ¬† ¬† [username]
¬† ¬† );

¬† ¬† if (checkUser.rows.length > 0) {
¬† ¬† ¬† return res.status(400).json({ 
¬† ¬† ¬† ¬† message: "Username ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß" 
¬† ¬† ¬† });
¬† ¬† }

¬† ¬† // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™ password ‡∏î‡πâ‡∏ß‡∏¢ bcrypt
¬† ¬† const saltRounds = 10;
¬† ¬† const hashedPassword = await bcrypt.hash(password, saltRounds);

¬† ¬† // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á database
¬† ¬† const result = await pool.query(
¬† ¬† ¬† `INSERT INTO users (username, password_hash, email, full_name, phone, role) 
¬† ¬† ¬† ¬†VALUES ($1, $2, $3, $4, $5, 'customer') 
¬† ¬† ¬† ¬†RETURNING user_id, username, email, full_name, role, created_at`,
¬† ¬† ¬† [username, hashedPassword, email, full_name || null, phone || null]
¬† ¬† );

¬† ¬† res.status(201).json({
¬† ¬† ¬† message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
¬† ¬† ¬† user: result.rows[0]
¬† ¬† });

¬† } catch (err) {
¬† ¬† console.error(err);
¬† ¬† res.status(500).json({ message: "Server error" });
¬† }
});

// POST /login - ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö
app.post("/login", async (req, res) => {
¬† const { username, password } = req.body;

¬† if (!username || !password) {
¬† ¬† return res.status(400).json({ 
¬† ¬† ¬† message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å username ‡πÅ‡∏•‡∏∞ password" 
¬† ¬† });
¬† }

¬† try {
¬† ¬† // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ user
¬† ¬† const result = await pool.query(
¬† ¬† ¬† "SELECT * FROM users WHERE username = $1",
¬† ¬† ¬† [username]
¬† ¬† );

¬† ¬† if (result.rows.length === 0) {
¬† ¬† ¬† // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏î‡πÄ‡∏î‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏Å‡∏±‡∏ö password ‡∏ú‡∏¥‡∏î
¬† ¬† ¬† return res.status(401).json({ 
¬† ¬† ¬† ¬† message: "Username ‡∏´‡∏£‡∏∑‡∏≠ Password ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" 
¬† ¬† ¬† });
¬† ¬† }

¬† ¬† const user = result.rows[0];

¬† ¬† // ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö password
¬† ¬† const isMatch = await bcrypt.compare(password, user.password_hash);

¬† ¬† if (!isMatch) {
¬† ¬† ¬† return res.status(401).json({ 
¬† ¬† ¬† ¬† message: "Username ‡∏´‡∏£‡∏∑‡∏≠ Password ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" 
¬† ¬† ¬† });
¬† ¬† }

¬† ¬† // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token
¬† ¬† const token = jwt.sign(
¬† ¬† ¬† { 
¬† ¬† ¬† ¬† user_id: user.user_id, 
¬† ¬† ¬† ¬† username: user.username,
¬† ¬† ¬† ¬† role: user.role 
¬† ¬† ¬† },
¬† ¬† ¬† process.env.JWT_SECRET,
¬† ¬† ¬† { expiresIn: "24h" }
¬† ¬† );

¬† ¬† res.json({
¬† ¬† ¬† message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
¬† ¬† ¬† token: token,
¬† ¬† ¬† user: {
¬† ¬† ¬† ¬† user_id: user.user_id,
¬† ¬† ¬† ¬† username: user.username,
¬† ¬† ¬† ¬† email: user.email,
¬† ¬† ¬† ¬† full_name: user.full_name,
¬† ¬† ¬† ¬† role: user.role
¬† ¬† ¬† }
¬† ¬† });

¬† } catch (err) {
¬† ¬† console.error(err);
¬† ¬† res.status(500).json({ message: "Server error" });
¬† }
});

// ====================================
// üîí Middleware ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Token
// ====================================
function authenticateToken(req, res, next) {
¬† const authHeader = req.headers["authorization"];
¬† const token = authHeader && authHeader.split(" ")[1];

¬† if (!token) {
¬† ¬† return res.status(401).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö Token ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ Login" });
¬† }

¬† jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
¬† ¬† if (err) {
¬† ¬† ¬† return res.status(403).json({ message: "Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
¬† ¬† }
¬† ¬† req.user = user;
¬† ¬† next();
¬† });
}

// GET /profile - ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡∏ï‡πâ‡∏≠‡∏á Login)
app.get("/profile", authenticateToken, async (req, res) => {
¬† try {
¬† ¬† const result = await pool.query(
¬† ¬† ¬† `SELECT user_id, username, email, full_name, phone, role, created_at 
¬† ¬† ¬† ¬†FROM users WHERE user_id = $1`,
¬† ¬† ¬† [req.user.user_id]
¬† ¬† );

¬† ¬† if (result.rows.length === 0) {
¬† ¬† ¬† return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ" });
¬† ¬† }

¬† ¬† res.json(result.rows[0]);
¬† } catch (err) {
¬† ¬† console.error(err);
¬† ¬† res.status(500).json({ message: "Server error" });
¬† }
});

// ====================================
// ‚öΩ APIs ‡∏™‡∏ô‡∏≤‡∏°‡∏ü‡∏∏‡∏ï‡∏ö‡∏≠‡∏•
// ====================================

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á slots ‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô 12:00-00:00
function generateTimeSlots(start = "12:00", end = "00:00", slotMinutes = 60) {
¬† const slots = [];
¬† let [h, m] = start.split(":").map(Number);
¬† // ‡πÅ‡∏õ‡∏•‡∏á 00:00 ‡πÄ‡∏õ‡πá‡∏ô 24:00 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Loop ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ß‡∏±‡∏ô
¬† let [endH, endM] = end === "00:00" ? [24, 0] : end.split(":").map(Number);

¬† while (h < endH || (h === endH && m < endM)) {
¬† ¬† const startTime = `${h.toString().padStart(2, "0")}:${m
¬† ¬† ¬† .toString()
¬† ¬† ¬† .padStart(2, "0")}`;
¬† ¬† let totalMinutes = h * 60 + m + slotMinutes;
¬† ¬† let nextH = Math.floor(totalMinutes / 60);
¬† ¬† let nextM = totalMinutes % 60;

    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ß‡∏•‡∏≤ 24:00 ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô 00:00
¬† ¬† const endTimeSlot =
¬† ¬† ¬† (nextH >= 24)
¬† ¬† ¬† ¬† ? "00:00"
¬† ¬† ¬† ¬† : `${nextH.toString().padStart(2, "0")}:${nextM
¬† ¬† ¬† ¬† ¬† ¬† .toString()
¬† ¬† ¬† ¬† ¬† ¬† .padStart(2, "0")}`;
¬† ¬† 
    slots.push({ start_time: startTime, end_time: endTimeSlot });
¬† ¬† h = nextH;
¬† ¬† m = nextM;

    if (h === 24 && m === 0) break; // ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏∂‡∏á 00:00 (24:00)
¬† }

¬† return slots;
}

// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤ HH:MM ‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏≤‡∏ó‡∏µ
function timeToMinutes(t) {
    if (t === "00:00") return 24 * 60; // 00:00 ‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô 24:00 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏±‡∏ö
¬†   const [h, m] = t.split(":").map(Number);
¬†   return h * 60 + m;
}

// GET /pitches - ‡∏î‡∏π‡∏™‡∏ô‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
app.get("/pitches", async (req, res) => {
¬† try {
¬† ¬† const result = await pool.query("SELECT * FROM pitches ORDER BY pitch_id");
¬† ¬† res.json(result.rows);
¬† } catch (err) {
¬† ¬† console.error("Error in /pitches:", err);
¬† ¬† res.status(500).send("Server error");
¬† }
});

// GET /pitches/available-slots?date=YYYY-MM-DD
app.get("/pitches/available-slots", async (req, res) => {
¬† const { date } = req.query;
¬† if (!date)
¬† ¬† return res
¬† ¬† ¬† .status(400)
¬† ¬† ¬† .json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á date ‡πÄ‡∏õ‡πá‡∏ô query param ‡πÄ‡∏ä‡πà‡∏ô 2025-10-23" });

¬† const slots = generateTimeSlots();

¬† try {
¬† ¬† const bookings = await pool.query(
¬† ¬† ¬† `SELECT pitch_id, start_time, end_time FROM bookings WHERE booking_date = $1`,
¬† ¬† ¬† [date]
¬† ¬† );

¬† ¬† const pitches = await pool.query(`SELECT * FROM pitches ORDER BY pitch_id`);
¬† ¬† const result = [];

¬† ¬† pitches.rows.forEach((pitch) => {
¬† ¬† ¬† const availableSlots = slots.filter((slot) => {
¬† ¬† ¬† ¬† return !bookings.rows.some(
¬† ¬† ¬† ¬† ¬† (b) =>
¬† ¬† ¬† ¬† ¬† ¬† b.pitch_id === pitch.pitch_id &&
¬† ¬† ¬† ¬† ¬† ¬† timeToMinutes(slot.start_time) < timeToMinutes(b.end_time) &&
¬† ¬† ¬† ¬† ¬† ¬† timeToMinutes(slot.end_time) > timeToMinutes(b.start_time)
¬† ¬† ¬† ¬† );
¬† ¬† ¬† });
¬† ¬† ¬† result.push({
¬† ¬† ¬† ¬† pitch_id: pitch.pitch_id,
¬† ¬† ¬† ¬† name: pitch.name,
¬† ¬† ¬† ¬† slots: availableSlots,
¬† ¬† ¬† });
¬† ¬† });

¬† ¬† res.json(result);
¬† } catch (err) {
¬† ¬† console.error("Error in /pitches/available-slots:", err);
¬† ¬† res.status(500).send("Server error");
¬† }
});

// POST /bookings - ‡∏à‡∏≠‡∏á‡∏™‡∏ô‡∏≤‡∏° (‡∏ï‡πâ‡∏≠‡∏á Login)
app.post("/bookings", authenticateToken, async (req, res) => {
¬† const { pitch_id, booking_date, start_time, duration_hours } = req.body;
¬† const user_id = req.user.user_id; // ‡∏î‡∏∂‡∏á user_id ‡∏à‡∏≤‡∏Å Token

¬† if (!pitch_id || !booking_date || !start_time || !duration_hours) {
¬† ¬† return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å field" });
¬† }

¬† // ‡πÅ‡∏õ‡∏•‡∏á duration ‡πÄ‡∏õ‡πá‡∏ô end_time
¬† let [h, m] = start_time.split(":").map(Number);
¬† let endH = h + Number(duration_hours);
¬† let endM = m;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö end_time
    const calculated_end_time = 
        (endH >= 24 ? "00" : endH.toString().padStart(2, "0")) + 
        ":" + 
        endM.toString().padStart(2, "0");

¬† try {
¬† ¬† // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏±‡∏ö: (A.start < B.end) AND (A.end > B.start)
¬† ¬† const check = await pool.query(
¬† ¬† ¬† `SELECT * FROM bookings 
¬† ¬† ¬† ¬†WHERE pitch_id=$1 AND booking_date=$2
¬† ¬† ¬† ¬† ¬†AND start_time < $3 AND end_time > $4`,
¬† ¬† ¬† [pitch_id, booking_date, calculated_end_time, start_time]
¬† ¬† );

¬† ¬† if (check.rows.length > 0) {
¬† ¬† ¬† return res
¬† ¬† ¬† ¬† .status(400)
¬† ¬† ¬† ¬† .json({ message: "‡∏™‡∏ô‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ" });
¬† ¬† }

¬† ¬† // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å booking
¬† ¬† const result = await pool.query(
¬† ¬† ¬† `INSERT INTO bookings (user_id, pitch_id, booking_date, start_time, end_time, status)
¬† ¬† ¬† ¬†VALUES ($1,$2,$3,$4,$5,'confirmed') RETURNING *`,
¬† ¬† ¬† [user_id, pitch_id, booking_date, start_time, calculated_end_time]
¬† ¬† );

¬† ¬† res.json(result.rows[0]);
¬† } catch (err) {
¬† ¬† console.error("Error in /bookings:", err);
¬† ¬† res.status(500).send("Server error");
¬† }
});

// -----------------------------
// Start server
// -----------------------------
const PORT = 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));